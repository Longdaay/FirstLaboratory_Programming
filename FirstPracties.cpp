#include <iostream>
#include <climits>
#include <Windows.h>

namespace s // пространство имен s для объединения типов данных для вводимого числа
{
	static union
	{
		long int digit;
		float digit_f;
	};
}
int count_qual = 0; // значение, на которое необходимо изменить заполнение массива
short param_f = FALSE; // переменная, которая определяет выбранный тип данных

void SetColor(int text, int bg) //Функция смены цвета, взятая из Интернета
{
	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdOut, (WORD)((bg << 4) | text));
}
void chooseFormat() // функция проверки значения в зависимости от выбранного формата
{
	using std::cout;
	using std::cin;
	char value[256]; // переменная, которая хранит выбранный формат числа
	// считываем выбранное значение
	cin >> value;
	if (strlen(value) == 1)// проверяем количество введенных символов. Если много, то просим ввести еще раз, иначе проверям выбранный формат
	{
		// устанавливаем количество значений для слепка числа в зависимости от его формата и также проверяем, входит ли значение вводимого числа в конкретный диапазон
		switch (value[0]) // проверям выбранный формат, взяв первый символ переменной value
		{
		case '1':
			::count_qual = 112; // устанавливаем глобальное значение для изменения диапазона массива 
			cout << "Ваш выбор short int" << '\n';
			if (s::digit < SHRT_MIN or s::digit > SHRT_MAX) // проверяем входит ли вводимое значение в рамки выбранного формата
			{
				cout << "Число выходит за пределы выбранного формата. Попробуйте выбрать другой" << '\n'; // недопустимое значение
				chooseFormat();
			}
			break;

		case '2':
			::count_qual = 96; // устанавливаем глобальное значение для изменения диапазона массива 
			cout << "Ваш выбор int" << '\n';
			if (s::digit < INT_MIN or s::digit > INT_MAX) // проверяем входит ли вводимое значение в рамки выбранного формата
			{
				cout << "Число выходит за пределы выбранного формата. Попробуйте выбрать другой" << '\n'; // недопустимое значение
				chooseFormat();
			}
			break;
		case '3':
			::count_qual = 96; // устанавливаем глобальное значение для изменения диапазона массива 
			cout << "Ваш выбор unsigned int" << '\n';
			if (s::digit < 0 or s::digit > UINT_MAX) // проверяем входит ли вводимое значение в рамки выбранного формата
			{
				cout << "Число выходит за пределы выбранного формата. Попробуйте выбрать другой" << '\n'; // недопустимое значение
				chooseFormat();
			}
			break;
		default:
			cout << "Число введено неверное. Введите номер заново" << '\n'; // если выбранный формат не соответсвует ни одному из предложенных
			chooseFormat();
		}
	}
	else // если введено символов больше необходимого
	{
		cout << "Необходимо ввести один символ. Попробуйте ввести заново" << '\n';
		chooseFormat();
	}
}
void chooseFormat_f() // функция проверки значения в зависимости от выбранного формата
{
	using std::cout;
	using std::cin;
	char value[256]; // переменная, которая хранит выбранный формат числа
	// считываем выбранное значение
	cin >> value;
	if (strlen(value) == 1)// проверяем количество введенных символов. Если много, то просим ввести еще раз, иначе проверям выбранный формат
	{
		// устанавливаем количество значений для слепка числа в зависимости от его формата и также проверяем, входит ли значение вводимого числа в конкретный диапазон
		switch (value[0]) // проверям выбранный формат, взяв первый символ переменной value
		{
		case '1':
			::count_qual = 96; // устанавливаем глобальное значение для изменения диапазона массива
			::param_f = 8; // определяет выбранный тип данных float
			cout << "Ваш выбор float" << '\n';
			if (s::digit < FLT_MIN or s::digit > FLT_MAX) // проверяем входит ли вводимое значение в рамки выбранного формата
			{
				cout << "Число выходит за пределы выбранного формата. Попробуйте выбрать другой" << '\n'; // недопустимое значение
				chooseFormat_f();
			}
			break;

		case '2':
			::param_f = 11; // определяет выбранный тип данных double
			cout << "Ваш выбор double" << '\n';
			if (s::digit < DBL_MIN or s::digit > DBL_MAX) // проверяем входит ли вводимое значение в рамки выбранного формата
			{
				cout << "Число выходит за пределы выбранного формата. Попробуйте выбрать другой" << '\n'; // недопустимое значение
				chooseFormat_f();
			}
			break;
		default:
			cout << "Число введено неверное. Введите номер заново" << '\n'; // если выбранный формат не соответсвует ни одному из предложенных
			chooseFormat_f();
		}
	}
	else // если введено символов больше необходимого
	{
		cout << "Необходимо ввести один символ. Попробуйте ввести заново" << '\n';
		chooseFormat_f();
	}
}
void mask_digit(const unsigned short qual, int revers_array[], int number_of_bit, bool result)
{
	using std::cout;
	// делаем слепок числа с помощью побитового сдвига и умножения в цикле
	for (number_of_bit; number_of_bit < qual - count_qual; number_of_bit++) // номер бита для сдвига, сравниваем номер бита с допустимым значением диапазона массива, добавляем 1 после каждой итерации
	{
		result = s::digit & (1U << number_of_bit); // производим сдвиг числа и записываем бит в переменную
		revers_array[number_of_bit] = result; // записываем в массив полученное значение 
	}
	cout << '\n'; // перевод строки
}
void print_revers_array(const unsigned short qual, int revers_array[])
{
	using std::cout;
	cout << "Двоичное представление числа: " << '\n' << '\n';
	bool counter = 0; // значение, которое позволяет контролировать первый значащий разряд числа
	// выводим на экран слепок числа,  перевернув его
	for (int i = qual - 1 - count_qual; i >= 0; i = i - 1) // берем последний бит в допустимом значении диапазона массива, цикл будет проходить до последнего значения бита, снижаем на 1 после каждой итерации
	{
		if (i == qual - 1 - count_qual) // отделяем знак от числа единожды
		{
			cout << revers_array[i]; // вывод значения бита
			cout << " "; // пробел отделяющий знак числа
		}
		else if (revers_array[i] == 0 and counter == 0) // проверяем выводим бит является ли значащим и вместе с ним равен ли параметр ЛОЖЬ. Необходимо для того, чтобы найти значащие биты и выделить их цветом
		{
			cout << revers_array[i]; // вывод значения бита
		}
		else
		{
			counter = 1; // устанавливаем в истину, как только получили первый значащий разряд
			SetColor(14, 0); // устанавливаем цвет шрифта в желтый
			cout << revers_array[i]; //вывод значения бита
		}
		if (i % 8 == 0) // отделяем после 8го значения пробелом для удобного восприятия числа
			cout << " ";
	}
	SetColor(7, 0); // возвращаем цвет шрифта в белый
}
void print_revers_array_f(const unsigned short qual, int revers_array[])
{
	using std::cout;
	cout << "Двоичное представление числа: " << '\n' << '\n';
	bool counter = 0; // значение, которое позволяет контролировать первый значащий разряд числа
	// выводим на экран слепок числа,  перевернув его
	for (int i = qual - 1 - count_qual; i >= 0; i = i - 1) // берем последний бит в допустимом значении диапазона массива, цикл будет проходить до последнего значения бита, снижаем на 1 после каждой итерации
	{
		if (i == qual - 1 - count_qual) // отделяем знак от числа единожды
		{
			cout << revers_array[i]; // вывод значения бита
			cout << " "; // пробел отделяющий знак числа
		}
		else if (i + param_f > qual - 1 - count_qual) // выделяем первые биты порядка вещественного цветом и выводим. После того, как условие станет ложным - выделяем биты мантиссы другим цветом и выводим 
		{
			SetColor(11, 0);
			cout << revers_array[i]; // вывод значения бита
		}
		else
		{
			SetColor(12, 0);
			cout << revers_array[i]; //вывод значения бита
		}
		if (i % 8 == 0) // отделяем после 8го значения пробелом для удобного восприятия числа
			cout << " ";
	}
	SetColor(7, 0); // возвращаем цвет шрифта в белый
}
long int checkdigit(bool param)
{
	using std::cout;
	using std::cin;
	while (true)
	{
		// вводим число, которое хотим представить в двоичной форме
		if (param == FALSE) // в зависимости от части задания проверям целое или вещественное число
			cin >> s::digit; // число целое
		else
			cin >> s::digit_f; // число вещественное

		if (cin.fail()) // ecли предыдущее извелечение оказлось неудачным,
		{
			cin.clear(); // то возвращаем cin в обычный режим работы
			cin.ignore(32767, '\n'); // и удаляем из буфера значения предыдущего ввода 
			cout << "Недопустимое заданное число. Введите число правильно" << '\n';
		}
		else
		{
			cin.ignore(32767, '\n'); // удаляем из буфера значения предыдущего ввода 
			return s::digit;
		}
	}
}
bool checkresult() // функция для проверки числа. Необходим для удобства использования функции для выполнения задания со сменой битов в числе
{
	bool result;
	if (s::digit >= 0)
		result = FALSE;
	else
		result = TRUE;
	
	return result;
}
void print_second_task(const unsigned short qual, int revers_array[], bool result, int number_of_bit, bool param) // функция для выполнения задания со сменой битов в числе
{
	using std::cout;
	// выполняем 2 задание 
	cout << '\n' << '\n' << "Второе задание" << '\n';
	cout << "Если число положительное - четные биты меняем на 0" << '\n';
	cout << "Если число отрицательное - нечетные биты меняем на 1" << '\n';

	if (s::digit >= 0)// Если число положительное - четные биты меняем на 0
	{
		for (int i = qual - 1 - count_qual; i >= 0; i = i - 1)
		{
			if (i % 2 != 0)
				s::digit = s::digit & (~(1U << i)); // устанавлививаем четный бит в 0
		}
	}
	else // Если число отрицательное - нечетные биты меняем на 1
	{
		for (int i = qual - 1 - count_qual; i >= 0; i = i - 1)
		{
			if (i % 2 == 0)
				s::digit = s::digit | (1U << i); // устанавливаем нечетный бит в 1
		}
	}
	mask_digit(qual, revers_array, number_of_bit, result);
	if(param == FALSE)
		print_revers_array(qual, revers_array);
	else
		print_revers_array_f(qual, revers_array);
	SetColor(7, 0); // возвращаем цвет шрифта в белый
	cout << "полученное значение = " << s::digit << '\n' << '\n';
}
int main()
{
	setlocale(0, ""); // локализация
	using std::cout;
	using std::cin;
	int number_of_bit = 0; // номер бита, которым производим сдвиг
	bool result = checkresult(); // переменная, которая хранит значения преобразования после сдвига 
	const unsigned short qual = 128; // обозначает разрядность будущего числа
	int revers_array[qual]; // массив, который хранит слепок числа в перевернутом виде
	bool param = FALSE; // переменная, которая хранит формат числа - "0" - целое число, "1" - вещественное число

	cout << "___________________ I ЧАСТЬ - _____________________" << '\n';
	cout << "                  Целое число           " << '\n';
	cout << "Введите целое число арабскими цифрами (Пример: 10, -10, 5251, 0): " << '\n';
	checkdigit(param); // проверка числа
	// выбираем формат значения
	cout << "Выберите формат числа:" << '\n';
	cout << "1 - short" << '\n';
	cout << "2 - int" << '\n';
	cout << "3 - unsigned int" << '\n';
	chooseFormat(); // функция проверки значения в зависимости от выбранного формата
	mask_digit(qual, revers_array, number_of_bit, result); // функция создания слепка числа
	print_revers_array(qual, revers_array); // функция вывода массива полученный значений, перевернув его
	print_second_task(qual, revers_array, result, number_of_bit, param); // задание № 2
	cout << '\n'; // пустая строка

	param = TRUE; // необходимо что б выполнить 2ую часть задания - чтобы произвести проверку вещественного числа
	count_qual = 0; // обнуляем значение, на которое необходимо изменить заполнение массива 
	cout << "___________________ II ЧАСТЬ - _____________________" << '\n';
	cout << "               Вещественное число           " << '\n';
	cout << "Введите неотрицательное вещественное число арабскими цифрами (Пример: 3.14, 15.0, 5251.432, 0.0): " << '\n';
	checkdigit(param); // проверка числа
	// выбираем формат значения
	cout << "Выберите формат числа:" << '\n';
	cout << "1 - float" << '\n';
	cout << "2 - double" << '\n';
	chooseFormat_f(); // функция проверки значения в зависимости от выбранного формата
	mask_digit(qual, revers_array, number_of_bit, result); // функция создания слепка числа
	print_revers_array_f(qual, revers_array); // функция вывода массива полученный значений, перевернув его
	//print_second_task(qual, revers_array, result, number_of_bit, param); // задание № 2
	cout << '\n'; // пустая строка
	
	return 0;
}